План действий:
Выделяем функциональность кнопки «Описание» в отдельный класс.
Интегрируем этот новый класс обратно в основной бот-класс.
Пример выделенного класса для кнопки «Описание»
Создадим класс DescriptionHandler, который обрабатывает события нажатия на кнопку «Описание».


package com.example.mybot.handlers;

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Message;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

@Component
@RequiredArgsConstructor
public class DescriptionHandler {

    private final Logger logger = LoggerFactory.getLogger(DescriptionHandler.class);

    /** * Отправляет сообщение с описанием программы. * * @param chatId ID чата, куда отправлять сообщение */
    public void handle(Message message) throws TelegramApiException {
        long chatId = message.getChatId();
        SendMessage response = new SendMessage(chatId, "Это описание функционала программы");
        execute(response);
    }

    protected void execute(SendMessage sendMessage) throws TelegramApiException {
        super.execute(sendMessage); // Используется в классе TelegramLongPollingBot
    }
}
Примечания:Этот класс требует внедрения TelegramLongPollingBot, но так как методы вроде execute() являются закрытыми методами родительского класса, мы сделаем инъекцию через конструктор и переопределим метод execute().

Однако лучше всего здесь воспользоваться шаблоном проектирования команда, поскольку классы будут вызывать разные типы поведения, связанного с обработкой сообщений. Давайте реализуем его:

Шаблон Command Pattern (шаблон команда)
Создадим интерфейс для всех наших обработчиков сообщений:


package com.example.mybot.commands;

import org.telegram.telegrambots.meta.api.objects.Message;

public interface Command {
    void process(Message message);
}
Реализация команды для описания программы:


package com.example.mybot.commands.impl;

import com.example.mybot.commands.Command;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Message;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

@Component
@RequiredArgsConstructor
public class DescriptionCommand implements Command {

    private final Logger logger = LoggerFactory.getLogger(DescriptionCommand.class);

    @Override
    public void process(Message message) {
        try {
            long chatId = message.getChatId();
            SendMessage response = new SendMessage(chatId, "Это описание функционала программы");
            execute(response);
        } catch (TelegramApiException e) {
            logger.error(e.getMessage(), e);
        }
    }

    protected void execute(SendMessage sendMessage) throws TelegramApiException {
        // Этот метод должен быть реализован в основном классе бота
    }
}
Модификация основного класса бота
Модифицируем основную реализацию MyTelegramBot для поддержки новых классов-команд:


// Импортируем необходимые интерфейсы и классы
import com.example.mybot.commands.Command;
import com.example.mybot.commands.impl.DescriptionCommand;

@Component
@RequiredArgsConstructor
public class MyTelegramBot extends TelegramLongPollingBot {

    private final Logger logger = LoggerFactory.getLogger(MyTelegramBot.class);
    private final BotConfig config;
    private final Map<String, Command> commandsMap;

    public MyTelegramBot(BotConfig config, Map<String, Command> commandsMap) {
        this.config = config;
        this.commandsMap = commandsMap;
    }

    @Override
    public void onUpdateReceived(Update update) {
        if (update.hasMessage() && update.getMessage().hasText()) {
            Message message = update.getMessage();
            String text = message.getText();

            if (commandsMap.containsKey(text)) {
                commandsMap.get(text).process(message);
            } else {
                SendMessage unknownCmdResponse = new SendMessage()
                        .setChatId(message.getChatId())
                        .setText("Команда не распознана.");
                try {
                    execute(unknownCmdResponse);
                } catch (TelegramApiException e) {
                    logger.error(e.getMessage(), e);
                }
            }
        }
    }

    // Остальной код оставляем неизмененным...
}
Итоги изменений:
Мы создали специализированный класс-обработчик для кнопки «Описание».
Использовали шаблон "команда" для лучшего разделения ответственности между разными типами обработчиков.
Сделали наш исходный класс бота более чистым и расширяемым.
Теперь легко добавлять новые команды, сохраняя общую архитектуру системы чистой и понятной.


